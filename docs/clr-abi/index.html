
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
        <link rel="canonical" href="https://jurakovic.github.io/runtime/clr-abi/">
      
      
        <link rel="prev" href="../readytorun-overview/">
      
      
        <link rel="next" href="../xplat-minidump-generation/">
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.6.23">
    
    
      
        <title>CLR ABI - The Book of the Runtime</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.84d31ad4.min.css">
      
        
        <link rel="stylesheet" href="../assets/stylesheets/palette.06af60db.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      
  


  
  

<script id="__analytics">function __md_analytics(){function e(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],e("js",new Date),e("config","G-233EMZJM16"),document.addEventListener("DOMContentLoaded",(function(){document.forms.search&&document.forms.search.query.addEventListener("blur",(function(){this.value&&e("event","search",{search_term:this.value})}));document$.subscribe((function(){var t=document.forms.feedback;if(void 0!==t)for(var a of t.querySelectorAll("[type=submit]"))a.addEventListener("click",(function(a){a.preventDefault();var n=document.location.pathname,d=this.getAttribute("data-md-value");e("event","feedback",{page:n,data:d}),t.firstElementChild.disabled=!0;var r=t.querySelector(".md-feedback__note [data-md-value='"+d+"']");r&&(r.hidden=!1)})),t.hidden=!1})),location$.subscribe((function(t){e("config","G-233EMZJM16",{page_path:t.pathname})}))}));var t=document.createElement("script");t.async=!0,t.src="https://www.googletagmanager.com/gtag/js?id=G-233EMZJM16",document.getElementById("__analytics").insertAdjacentElement("afterEnd",t)}</script>
  
    <script>"undefined"!=typeof __md_analytics&&__md_analytics()</script>
  

    
    
    
  </head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="indigo" data-md-color-accent="indigo">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#clr-abi" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="The Book of the Runtime" class="md-header__button md-logo" aria-label="The Book of the Runtime" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            The Book of the Runtime
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              CLR ABI
            
          </span>
        </div>
      </div>
    </div>
    
      
        <form class="md-header__option" data-md-component="palette">
  
    
    
    
    <input class="md-option" data-md-color-media="(prefers-color-scheme: light)" data-md-color-scheme="default" data-md-color-primary="indigo" data-md-color-accent="indigo"  aria-label="Switch to dark mode"  type="radio" name="__palette" id="__palette_0">
    
      <label class="md-header__button md-icon" title="Switch to dark mode" for="__palette_1" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a4 4 0 0 0-4 4 4 4 0 0 0 4 4 4 4 0 0 0 4-4 4 4 0 0 0-4-4m0 10a6 6 0 0 1-6-6 6 6 0 0 1 6-6 6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12z"/></svg>
      </label>
    
  
    
    
    
    <input class="md-option" data-md-color-media="(prefers-color-scheme: dark)" data-md-color-scheme="slate" data-md-color-primary="black" data-md-color-accent="indigo"  aria-label="Switch to light mode"  type="radio" name="__palette" id="__palette_1">
    
      <label class="md-header__button md-icon" title="Switch to light mode" for="__palette_0" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 18c-.89 0-1.74-.2-2.5-.55C11.56 16.5 13 14.42 13 12s-1.44-4.5-3.5-5.45C10.26 6.2 11.11 6 12 6a6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12z"/></svg>
      </label>
    
  
</form>
      
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      
      
        <label class="md-header__button md-icon" for="__search">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        </label>
        <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
      
    
    
      <div class="md-header__source">
        <a href="https://github.com/jurakovic/runtime" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 7.1.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2025 Fonticons, Inc.--><path d="M439.6 236.1 244 40.5c-5.4-5.5-12.8-8.5-20.4-8.5s-15 3-20.4 8.4L162.5 81l51.5 51.5c27.1-9.1 52.7 16.8 43.4 43.7l49.7 49.7c34.2-11.8 61.2 31 35.5 56.7-26.5 26.5-70.2-2.9-56-37.3L240.3 199v121.9c25.3 12.5 22.3 41.8 9.1 55-6.4 6.4-15.2 10.1-24.3 10.1s-17.8-3.6-24.3-10.1c-17.6-17.6-11.1-46.9 11.2-56v-123c-20.8-8.5-24.6-30.7-18.6-45L142.6 101 8.5 235.1C3 240.6 0 247.9 0 255.5s3 15 8.5 20.4l195.6 195.7c5.4 5.4 12.7 8.4 20.4 8.4s15-3 20.4-8.4l194.7-194.7c5.4-5.4 8.4-12.8 8.4-20.4s-3-15-8.4-20.4"/></svg>
  </div>
  <div class="md-source__repository">
    dotnet/runtime
  </div>
</a>
      </div>
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
                
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="The Book of the Runtime" class="md-nav__button md-logo" aria-label="The Book of the Runtime" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    The Book of the Runtime
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/jurakovic/runtime" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 7.1.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2025 Fonticons, Inc.--><path d="M439.6 236.1 244 40.5c-5.4-5.5-12.8-8.5-20.4-8.5s-15 3-20.4 8.4L162.5 81l51.5 51.5c27.1-9.1 52.7 16.8 43.4 43.7l49.7 49.7c34.2-11.8 61.2 31 35.5 56.7-26.5 26.5-70.2-2.9-56-37.3L240.3 199v121.9c25.3 12.5 22.3 41.8 9.1 55-6.4 6.4-15.2 10.1-24.3 10.1s-17.8-3.6-24.3-10.1c-17.6-17.6-11.1-46.9 11.2-56v-123c-20.8-8.5-24.6-30.7-18.6-45L142.6 101 8.5 235.1C3 240.6 0 247.9 0 255.5s3 15 8.5 20.4l195.6 195.7c5.4 5.4 12.7 8.4 20.4 8.4s15-3 20.4-8.4l194.7-194.7c5.4-5.4 8.4-12.8 8.4-20.4s-3-15-8.4-20.4"/></svg>
  </div>
  <div class="md-source__repository">
    dotnet/runtime
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Introduction
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../botr-faq/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Book of the Runtime FAQ
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../intro-to-clr/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Introduction to the Common Language Runtime
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../garbage-collection/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Garbage Collection Design
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../threading/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Threading
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../ryujit-overview/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    RyuJIT Overview
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../porting-ryujit/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Porting RyuJIT to other platforms
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../type-system/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Type System
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../type-loader/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Type Loader
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../method-descriptor/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Method Descriptor
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../virtual-stub-dispatch/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Virtual Stub Dispatch
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../stackwalking/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Stack Walking
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../corelib/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    System.Private.CoreLib and calling into the runtime
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../dac-notes/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Data Access Component (DAC) Notes
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../profiling/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Profiling
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../profilability/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Implementing Profilability
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../exceptions/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    What Every Dev needs to Know About Exceptions in the Runtime
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../readytorun-overview/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    ReadyToRun Overview
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  
  <span class="md-ellipsis">
    CLR ABI
    
  </span>
  

      </a>
      
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../xplat-minidump-generation/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Cross-platform Minidumps
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../mixed-mode/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Mixed Mode Assemblies
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../guide-for-porting/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Guide For Porting
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../vectors-and-intrinsics/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Vectors and Intrinsics
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../ilc-architecture/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    ILC Compiler Architecture
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../managed-type-system/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Managed Type System Overview
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../r2r-perfmap-format/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Ready to run PerfMap format
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../readytorun-format/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    ReadyToRun File Format
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../shared-generics/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Shared Generics Design
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../logging/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Runtime logging for developers
    
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
                
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" hidden>
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  
  



  
  
    
      
    
    <a href="https://github.com/dotnet/runtime/blob/main/docs/design/coreclr/botr/clr-abi.md" title="View source of this page" target="_blank" class="md-content__button md-icon">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M17 18c.56 0 1 .44 1 1s-.44 1-1 1-1-.44-1-1 .44-1 1-1m0-3c-2.73 0-5.06 1.66-6 4 .94 2.34 3.27 4 6 4s5.06-1.66 6-4c-.94-2.34-3.27-4-6-4m0 6.5a2.5 2.5 0 0 1-2.5-2.5 2.5 2.5 0 0 1 2.5-2.5 2.5 2.5 0 0 1 2.5 2.5 2.5 2.5 0 0 1-2.5 2.5M9.27 20H6V4h7v5h5v4.07c.7.08 1.36.25 2 .49V8l-6-6H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h4.5a8.2 8.2 0 0 1-1.23-2"/></svg>
    </a>
  


<h1 id="clr-abi">CLR ABI</h1>
<p>This document describes the .NET Common Language Runtime (CLR) software conventions (or ABI, "Application Binary Interface"). It focuses on the ABI for the x64 (aka, AMD64), ARM (aka, ARM32 or Thumb-2), and ARM64 processor architectures. Documentation for the x86 ABI is somewhat scant, but information on the basics of the calling convention is included at the bottom of this document.</p>
<p>It describes requirements that the Just-In-Time (JIT) compiler imposes on the VM and vice-versa.</p>
<p>A note on the JIT codebases: JIT32 refers to the original JIT codebase that originally generated x86 code and was later ported to generate ARM code. JIT64 refers to the legacy .NET Framework codebase that supports AMD64. The RyuJIT compiler evolved from JIT32, and now supports all platforms and architectures. See <a href="https://devblogs.microsoft.com/dotnet/the-ryujit-transition-is-complete">this post</a> for more RyuJIT history.</p>
<p>NativeAOT refers to a runtime that is optimized for ahead-of-time compilation (AOT). The NativeAOT ABI differs in a few details for simplicity and consistency across platforms.</p>
<h1 id="getting-started">Getting started</h1>
<p>Read everything in the documented Windows and non-Windows ABI documentation. The CLR follows those basic conventions. This document only describes things that are CLR-specific, or exceptions from those documents.</p>
<h2 id="windows-abi-documentation">Windows ABI documentation</h2>
<p>AMD64: See <a href="https://learn.microsoft.com/cpp/build/x64-software-conventions">x64 Software Conventions</a>.</p>
<p>ARM: See <a href="https://learn.microsoft.com/cpp/build/overview-of-arm-abi-conventions">Overview of ARM32 ABI Conventions</a>.</p>
<p>ARM64: See <a href="https://learn.microsoft.com/cpp/build/arm64-windows-abi-conventions">Overview of ARM64 ABI conventions</a>.</p>
<h2 id="non-windows-abi-documentation">Non-Windows ABI documentation</h2>
<p>Arm corporation ABI documentation (for ARM32 and ARM64) is <a href="https://developer.arm.com/architectures/system-architectures/software-standards/abi">here</a> and <a href="https://github.com/ARM-software/abi-aa">here</a>.
Apple's ARM64 calling convention differences can be found <a href="https://developer.apple.com/documentation/xcode/writing-arm64-code-for-apple-platforms">here</a>.</p>
<p>The Linux System V x86_64 ABI is documented in <a href="https://github.com/hjl-tools/x86-psABI/wiki/x86-64-psABI-1.0.pdf">System V Application Binary Interface / AMD64 Architecture Processor Supplement</a>, with document source material <a href="https://gitlab.com/x86-psABIs/x86-64-ABI">here</a>.</p>
<p>The LoongArch64 ABI documentation is <a href="https://github.com/loongson/LoongArch-Documentation/blob/main/docs/LoongArch-ELF-ABI-EN.adoc">here</a></p>
<p>The RISC-V ABIs Specification: <a href="https://github.com/riscv-non-isa/riscv-elf-psabi-doc/releases/latest">latest release</a>, <a href="https://github.com/riscv-non-isa/riscv-elf-psabi-doc/releases">latest draft</a>, <a href="https://github.com/riscv-non-isa/riscv-elf-psabi-doc">document source repo</a>.</p>
<h1 id="general-unwindframe-layout">General Unwind/Frame Layout</h1>
<p>For all non-x86 platforms, all methods must have unwind information so the garbage collector (GC) can unwind them (unlike native code in which a leaf method may be omitted).</p>
<p>ARM and ARM64: Managed methods must always push LR on the stack, and create a minimal frame, so that the method can be properly hijacked using return address hijacking.</p>
<h2 id="frame-pointer-chains">Frame pointer chains</h2>
<p>A frame pointer chain exists when the frame pointer register points to a location on the stack containing the address of the saved previous frame pointer value (from a caller of the current function). This chaining is required is certain scenarios, such as:
1. gdb debugger stack walking on Linux.
2. ETW event trace stack walking.</p>
<p>There are two considerations:
1. Reserving the frame pointer register for stack walking, and not using it for other purposes, such as general-purpose code generation, and
2. Creating a frame chain.</p>
<p>Note that even if a function is not added to the frame chain, as long as the function does not modify the frame pointer, the existing frame chain is still viable, although that function will not appear when walking the chain. The JIT may have reasons to create and use a frame pointer register even if a frame chain is not created, such as to access main function local variables within an exception handling funclet.</p>
<p>The frame pointer register is, for each architecture: ARM: r11, ARM64: x29, x86: EBP, x64: RBP.</p>
<p>The JIT creates frame chains most of the time for all platforms <em>except</em> Windows x64. Very simple functions may not get added to the frame chain, with the intent to improve performance by reducing frame setup cost (the heuristics for this choice are in <code>Compiler::rpMustCreateEBPFrame()</code>). For Windows x64, unwinding will always be done using the generated unwind codes, and not simple frame chain traversal.</p>
<p>Some additional links:
- See <a href="https://github.com/dotnet/runtime/blob/main/docs/design/coreclr/jit/arm64-jit-frame-layout.md">ARM64 JIT frame layout</a> for documentation on that architecture's frame design.
- The CoreCLR change to always create RBP chains on Unix x64 is <a href="https://github.com/dotnet/coreclr/pull/4019">here</a> (issue with discussion <a href="https://github.com/dotnet/runtime/issues/4651">here</a>).</p>
<h1 id="specialextra-parameters">Special/extra parameters</h1>
<h2 id="the-this-pointer">The <code>this</code> pointer</h2>
<p>The managed <code>this</code> pointer is treated like a new kind of argument not covered by the native ABI, so we chose to always pass it as the first argument in (AMD64) <code>RCX</code> or (ARM, ARM64) <code>R0</code>.</p>
<p>AMD64-only: Up to .NET Framework 4.5, the managed <code>this</code> pointer was treated just like the native <code>this</code> pointer (meaning it was the second argument when the call used a return buffer and was passed in RDX instead of RCX). Starting with .NET Framework 4.5, it is always the first argument.</p>
<h2 id="varargs">Varargs</h2>
<p>Varargs refers to passing or receiving a variable number of arguments for a call.</p>
<p>C# varargs, using the <code>params</code> keyword, are at the IL level just normal calls with a fixed number of parameters.</p>
<p>Managed varargs (using C#'s pseudo-documented "...", <code>__arglist</code>, etc.) are implemented almost exactly like C++ varargs. The biggest difference is that the JIT adds a "vararg cookie" after the optional return buffer and the optional <code>this</code> pointer, but before any other user arguments. The callee must spill this cookie and all subsequent arguments into their home location, as they may be addressed via pointer arithmetic starting with the cookie as a base. The cookie happens to be to a pointer to a signature that the runtime can parse to (1) report any GC pointers within the variable portion of the arguments or (2) type-check (and properly walk over) any arguments extracted via ArgIterator. This is marked by <code>IMAGE_CEE_CS_CALLCONV_VARARG</code>, which should not be confused with <code>IMAGE_CEE_CS_CALLCONV_NATIVEVARARG</code>, which really is exactly native varargs (no cookie) and should only appear in PInvoke IL stubs, which properly handle pinning and other GC magic.</p>
<p>On AMD64, just like native, any floating point arguments passed in floating point registers (including the fixed arguments) will be shadowed (i.e. duplicated) in the integer registers.</p>
<p>On ARM and ARM64, just like native, nothing is put in the floating point registers.</p>
<p>However, unlike native varargs, all floating point arguments are not promoted to double (<code>R8</code>), and instead retain their original type (<code>R4</code> or <code>R8</code>) (although this does not preclude an IL generator like managed C++ from explicitly injecting an upcast at the call-site and adjusting the call-site-sig appropriately). This leads to unexpected behavior when native C++ is ported to C# or even just managed via the different flavors of managed C++.</p>
<p>Managed varargs are supported on Windows only.</p>
<p>Managed/native varargs are supported on Windows only. Support for managed/native varargs on non-Windows platforms is tracked by <a href="https://github.com/dotnet/runtime/issues/82081">this issue</a>.</p>
<h2 id="generics">Generics</h2>
<p><em>Shared generics</em>. In cases where the code address does not uniquely identify a generic instantiation of a method, then a 'generic instantiation parameter' is required. Often the <code>this</code> pointer can serve dual-purpose as the instantiation parameter. When the <code>this</code> pointer is not the generic parameter, the generic parameter is passed as an additional argument. On ARM and AMD64, it is passed after the optional return buffer and the optional <code>this</code> pointer, but before any user arguments. On ARM64 and RISC-V, the generic parameter is passed after the optional <code>this</code> pointer, but before any user arguments. On x86, if all arguments of the function including <code>this</code> pointer fit into argument registers (ECX and EDX) and we still have argument registers available, we store the hidden argument in the next available argument register. Otherwise it is passed as the last stack argument. For generic methods (where there is a type parameter directly on the method, as compared to the type), the generic parameter currently is a MethodDesc pointer (I believe an InstantiatedMethodDesc). For static methods (where there is no <code>this</code> pointer) the generic parameter is a MethodTable pointer/TypeHandle.</p>
<p>Sometimes the VM asks the JIT to report and keep alive the generics parameter. In this case, it must be saved on the stack someplace and kept alive via normal GC reporting (if it was the <code>this</code> pointer, as compared to a MethodDesc or MethodTable) for the entire method except the prolog and epilog. Also note that the code to home it, must be in the range of code reported as the prolog in the GC info (which probably isn't the same as the range of code reported as the prolog in the unwind info).</p>
<p>There is no defined/enforced/declared ordering between the generic parameter and the varargs cookie because the runtime does not support that combination. There are chunks of code in the VM and JITs that would appear to support that, but other places assert and disallow it, so nothing is tested, and I would assume there are bugs and differences (i.e. one JIT using a different ordering than the other JIT or the VM).</p>
<h3 id="example">Example</h3>
<div class="highlight"><pre><span></span><code>call([&quot;this&quot; pointer] [return buffer pointer] [generics context|varargs cookie] [userargs]*)
</code></pre></div>
<h2 id="async">Async</h2>
<p>Async calling convention is additive to other calling conventions when supported. The set of scenarios is constrained to regular static/virtual calls and does not, for example, support PInvokes or varargs. At the minimum ordinary static calls, calls with <code>this</code> parameter or generic hidden parameters are supported.</p>
<p>Async calling convention adds an extra <code>Continuation</code> parameter and an extra return, which sematically takes precedence when not <code>null</code>. A non-null <code>Continuation</code> upon return signals that the computation is not complete and the formal result is not ready. A non-null argument means that the function is resuming and should extract the state from the <code>Continuation</code> and continue execution (while ignoring all other arguments).</p>
<p>The <code>Continuation</code> is a managed object and needs to be tracked accordingly. The GC info includes the continuation result as live at Async call sites.</p>
<h3 id="returning-continuation">Returning <code>Continuation</code></h3>
<p>To return <code>Continuation</code> we use a volatile/calee-trash register that cannot be used to return the actual result.</p>
<table>
<thead>
<tr>
<th>arch</th>
<th><code>REG_ASYNC_CONTINUATION_RET</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>x86</td>
<td>ecx</td>
</tr>
<tr>
<td>x64</td>
<td>rcx</td>
</tr>
<tr>
<td>arm</td>
<td>r2</td>
</tr>
<tr>
<td>arm64</td>
<td>x2</td>
</tr>
<tr>
<td>risc-v</td>
<td>a2</td>
</tr>
</tbody>
</table>
<h3 id="passing-continuation-argument">Passing <code>Continuation</code> argument</h3>
<p>The <code>Continuation</code> parameter is passed at the same position as generic instantiation parameter or immediately after, if both present. For x86 the argument order is reversed.</p>
<div class="highlight"><pre><span></span><code>call([&quot;this&quot; pointer] [return buffer pointer] [generics context] [continuation] [userargs])   // not x86

call([&quot;this&quot; pointer] [return buffer pointer] [userargs] [continuation] [generics context])   // x86
</code></pre></div>
<h2 id="amd64-only-by-value-value-types">AMD64-only: by-value value types</h2>
<p>Just like native, AMD64 has implicit-byrefs. Any structure (value type in IL parlance) that is not 1, 2, 4, or 8 bytes in size (i.e., 3, 5, 6, 7, or &gt;= 9 bytes in size) that is declared to be passed by value, is instead passed by reference. For JIT generated code, it follows the native ABI where the passed-in reference is a pointer to a compiler generated temp local on the stack. However, there are some cases within remoting or reflection where apparently stackalloc is too hard, and so they pass in pointers within the GC heap, thus the JITed code must report these implicit byref parameters as interior pointers (BYREFs in JIT parlance), in case the callee is one of these reflection paths. Similarly, all writes must use checked write barriers.</p>
<p>The AMD64 native calling conventions (Windows 64 and System V) require return buffer address to be returned by callee in RAX. JIT also follows this rule.</p>
<h2 id="risc-v-only-structs-passedreturned-according-to-hardware-floating-point-calling-convention">RISC-V only: structs passed/returned according to hardware floating-point calling convention</h2>
<p>Passing/returning structs according to hardware floating-point calling convention like native is currently <a href="https://github.com/dotnet/runtime/issues/107386">supported only up to 16 bytes</a>, ones larger than that differ from the standard ABI and are passed/returned according to integer calling convention (by implicit reference).</p>
<h2 id="return-buffers">Return buffers</h2>
<p>Since .NET 10, return buffers must always be allocated on the stack by the caller. After the call, the caller is responsible for copying the return buffer to the final destination using write barriers if necessary. The JIT can assume that the return buffer is always on the stack and may optimize accordingly, such as by omitting write barriers when writing GC pointers to the return buffer. In addition, the buffer is allowed to be used for temporary storage within the method since its content must not be aliased or cross-thread visible.</p>
<p>ARM64-only: When a method returns a structure that is larger than 16 bytes the caller reserves a return buffer of sufficient size and alignment to hold the result. The address of the buffer is passed as an argument to the method in <code>R8</code> (defined in the JIT as <code>REG_ARG_RET_BUFF</code>). The callee isn't required to preserve the value stored in <code>R8</code>.</p>
<h2 id="hidden-parameters">Hidden parameters</h2>
<p><em>Stub dispatch</em> - when a virtual call uses a VSD stub, rather than back-patching the calling code (or disassembling it), the JIT must place the address of the stub used to load the call target, the "stub indirection cell", in (x86) <code>EAX</code> / (AMD64) <code>R11</code> / (ARM) <code>R4</code> / (ARM NativeAOT ABI) <code>R12</code> / (ARM64) <code>R11</code>. In the JIT, this is encapsulated in the <code>VirtualStubParamInfo</code> class.</p>
<p><em>Calli Pinvoke</em> - The VM wants the address of the PInvoke in (AMD64) <code>R10</code> / (ARM) <code>R12</code> / (ARM64) <code>R14</code> (In the JIT: <code>REG_PINVOKE_TARGET_PARAM</code>), and the signature (the pinvoke cookie) in (AMD64) <code>R11</code> / (ARM) <code>R4</code> / (ARM64) <code>R15</code> (in the JIT: <code>REG_PINVOKE_COOKIE_PARAM</code>).</p>
<p><em>Normal PInvoke</em> - The VM shares IL stubs based on signatures, but wants the right method to show up in call stack and exceptions, so the MethodDesc for the exact PInvoke is passed in the (x86) <code>EAX</code> / (AMD64) <code>R10</code> / (ARM, ARM64) <code>R12</code> (in the JIT: <code>REG_SECRET_STUB_PARAM</code>). Then in the IL stub, when the JIT gets <code>CORJIT_FLG_PUBLISH_SECRET_PARAM</code>, it must move the register into a compiler temp. The value is returned for the intrinsic <code>NI_System_StubHelpers_GetStubContext</code>.</p>
<h2 id="small-primitive-returns">Small primitive returns</h2>
<p>Primitive value types smaller than 32-bits are widened to 32-bits: signed small types are sign extended and unsigned small types are zero extended. This can be different from the standard calling conventions that may leave the state of unused bits in the return register undefined.</p>
<h2 id="small-primitive-arguments">Small primitive arguments</h2>
<p>Small primitive arguments have undefined upper bits. This can be different from the standard calling conventions that may require normalization (e.g. on ARM32 and Apple ARM64).</p>
<p>On RISC-V small primitive arguments are extended according to standard calling conventions.</p>
<h1 id="pinvokes">PInvokes</h1>
<p>The convention is that any method with an InlinedCallFrame (either an IL stub or a normal method with an inlined PInvoke) saves/restores all non-volatile integer registers in its prolog/epilog respectively. This is done so that the InlinedCallFrame can just contain a return address, a stack pointer and a frame pointer. Then using just those three it can start a full stack walk using the normal RtlVirtualUnwind.</p>
<p>When encountering a PInvoke, the JIT will query the VM if the GC transition should be suppressed. Suppression of the GC transition is indicated by the addition of an attribute on the PInvoke definition. If the VM indicates the GC transition is to be suppressed, the PInvoke frame will be omitted in either the IL stub or inlined scenario and a GC Poll will be inserted near the unmanaged call site. If an enclosing function contains more than one inlined PInvoke but not all have requested a suppression of the GC transition a PInvoke frame will still be constructed for the other inlined PInvokes.</p>
<p>For AMD64, a method with an InlinedCallFrame must use RBP as the frame register.</p>
<p>For ARM and ARM64, we will also always use a frame pointer (R11). That is partially due to the frame chaining requirement. However, the VM also requires it for PInvokes with InlinedCallFrames.</p>
<p>For ARM, the VM also has a dependency on <code>REG_SAVED_LOCALLOC_SP</code>.</p>
<p>All these dependencies show up in the implementation of <code>InlinedCallFrame::UpdateRegDisplay</code>.</p>
<p>JIT32 only generates one epilog (and causes all returns to branch to it) when there are PInvokes/InlinedCallFrame in the current method.</p>
<h2 id="per-frame-pinvoke-initialization">Per-frame PInvoke initialization</h2>
<p>The InlinedCallFrame is initialized once at the head of IL stubs and once in each path that does an inlined PInvoke.</p>
<p>In JIT64 this happens in blocks that actually contain calls, but pushing it out of loops that have landing pads, and then looking for dominator blocks. For IL stubs and methods with EH, we give up and place the initialization in the first block.</p>
<p>In RyuJIT/JIT32 (ARM), all methods are treated like JIT64's IL stubs (meaning the per-frame initialization happens once just after the prolog).</p>
<p>The JIT generates a call to <code>CORINFO_HELP_INIT_PINVOKE_FRAME</code> passing the address of the InlinedCallFrame and either NULL or the secret parameter for IL stubs. <code>JIT_InitPInvokeFrame</code> initializes the InlinedCallFrame and sets it to point to the current Frame chain top. Then it returns the current thread's native Thread object.</p>
<p>On AMD64, the JIT generates code to save RSP and RBP into the InlinedCallFrame.</p>
<p>For IL stubs only, the per-frame initialization includes setting <code>Thread-&gt;m_pFrame</code> to the InlinedCallFrame (effectively 'pushing' the Frame).</p>
<h2 id="per-call-site-pinvoke-work">Per-call-site PInvoke work</h2>
<p>The below is performed when the GC transition is not suppressed.</p>
<ol>
<li>For direct calls, the JITed code sets <code>InlinedCallFrame-&gt;m_pDatum</code> to the MethodDesc of the call target.<ul>
<li>For JIT64, indirect calls within IL stubs sets it to the secret parameter (this seems redundant, but it might have changed since the per-frame initialization?).</li>
<li>For JIT32 (ARM) indirect calls, it sets this member to the size of the pushed arguments, according to the comments. The implementation however always passed 0.</li>
</ul>
</li>
<li>For JIT64/AMD64 only: Next for non-IL stubs, the InlinedCallFrame is 'pushed' by setting <code>Thread-&gt;m_pFrame</code> to point to the InlinedCallFrame (recall that the per-frame initialization already set <code>InlinedCallFrame-&gt;m_pNext</code> to point to the previous top). For IL stubs this step is accomplished in the per-frame initialization.</li>
<li>The Frame is made active by setting <code>InlinedCallFrame-&gt;m_pCallerReturnAddress</code>.</li>
<li>The code then toggles the GC mode by setting <code>Thread-&gt;m_fPreemptiveGCDisabled = 0</code>.</li>
<li>Starting now, no GC pointers may be live in registers. RyuJit LSRA meets this requirement by adding special refPosition <code>RefTypeKillGCRefs</code> before unmanaged calls and special helpers.</li>
<li>Then comes the actual call/PInvoke.</li>
<li>The GC mode is set back by setting <code>Thread-&gt;m_fPreemptiveGCDisabled = 1</code>.</li>
<li>Then we check to see if <code>g_TrapReturningThreads</code> is set (non-zero). If it is, we call <code>CORINFO_HELP_STOP_FOR_GC</code>.<ul>
<li>For ARM, this helper call preserves the return register(s): <code>R0</code>, <code>R1</code>, <code>S0</code>, and <code>D0</code>.</li>
<li>For AMD64, the generated code must manually preserve the return value of the PInvoke by moving it to a non-volatile register or a stack location.</li>
</ul>
</li>
<li>Starting now, GC pointers may once again be live in registers.</li>
<li>Clear the <code>InlinedCallFrame-&gt;m_pCallerReturnAddress</code> back to 0.</li>
<li>For JIT64/AMD64 only: For non-IL stubs 'pop' the Frame chain by resetting <code>Thread-&gt;m_pFrame</code> back to <code>InlinedCallFrame.m_pNext</code>.</li>
</ol>
<p>Saving/restoring all the non-volatile registers helps by preventing any registers that are unused in the current frame from accidentally having a live GC pointer value from a parent frame. The argument and return registers are 'safe' because they cannot be GC refs. Any refs should have been pinned elsewhere and instead passed as native pointers.</p>
<p>For IL stubs, the Frame chain isn't popped at the call site, so instead it must be popped right before the epilog and right before any jmp calls. It looks like we do not support tail calls from PInvoke IL stubs?</p>
<h1 id="exception-handling">Exception handling</h1>
<p>This section describes the conventions the JIT needs to follow when generating code to implement managed exception handling (EH). The JIT and VM must agree on these conventions for a correct implementation.</p>
<h2 id="funclets">Funclets</h2>
<p>For all platforms, managed EH handlers (finally, fault, filter, filter-handler, and catch) are extracted into their own 'funclets'. To the OS they are treated just like first class functions (separate PDATA and XDATA (<code>RUNTIME_FUNCTION</code> entry), etc.). The CLR currently treats them just like part of the parent function in many ways. The main function and all funclets must be allocated in a single code allocation (see hot cold splitting). They 'share' GC info. Only the main function prolog can be hot patched.</p>
<p>The only way to enter a handler funclet is via a call. In the case of an exception, the call is from the VM's EH subsystem as part of exception dispatch/unwind. In the non-exceptional case, this is called local unwind or a non-local exit. In C# this is accomplished by simply falling-through/out of a try body or an explicit goto. In IL this is always accomplished via a LEAVE opcode, within a try body, targeting an IL offset outside the try body. In such cases the call is from the JITed code of the parent function.</p>
<h2 id="cloned-finallys">Cloned finallys</h2>
<p>RyuJIT attempts to speed the normal control flow by 'inlining' a called finally along the 'normal' control flow (i.e., leaving a try body in a non-exceptional manner via C# fall-through). This optimization is supported on all architectures.</p>
<h2 id="invoking-finallysnon-local-exits">Invoking Finallys/Non-local exits</h2>
<p>In order to have proper forward progress and <code>Thread.Abort</code> semantics, there are restrictions on where a call-to-finally can be, and what the call site must look like. The return address can <strong>NOT</strong> be in the corresponding try body (otherwise the VM would think the finally protects itself). The return address <strong>MUST</strong> be within any outer protected region (so exceptions from the finally body are properly handled).</p>
<p>RyuJIT creates something similar to a jump island: a block of code outside the try body that calls the finally and then branches to the final target of the leave/non-local-exit. This jump island is then marked in the EH tables as if it were a cloned finally. The cloned finally clause prevents a Thread.Abort from firing before entering the handler. By having the return address outside of the try body we satisfy the other constraint.</p>
<h2 id="threadabortexception-considerations">ThreadAbortException considerations</h2>
<p>There are three kinds of thread abort: (1) rude thread abort, that cannot be stopped, and doesn't run (all?) handlers, (2) calls to the <code>Thread.Abort()</code> api, and (3) asynchronous thread abort, injected from another thread.</p>
<p>Note that ThreadAbortException is fully available in the desktop framework, and is heavily used in ASP.NET, for example. However, it is not supported in .NET Core, CoreCLR, or the Windows 8 "modern app profile". Nonetheless, the JIT generates ThreadAbort-compatible code on all platforms.</p>
<p>For non-rude thread abort, the VM walks the stack, running any catch handler that catches ThreadAbortException (or a parent, like System.Exception, or System.Object), and running finallys. There is one very particular characteristic of ThreadAbortException: if a catch handler has caught ThreadAbortException, and the handler returns from handling the exception without calling Thread.ResetAbort(), then the VM <em>automatically re-raises ThreadAbortException</em>. To do so, it uses the resume address that the catch handler returned as the effective address where the re-raise is considered to have been raised. This is the address of the label that is specified by a LEAVE opcode within the catch handler. There are cases where the JIT must insert synthetic "step blocks" such that this label is within an appropriate enclosing "try" region, to ensure that the re-raise can be caught by an enclosing catch handler.</p>
<p>For example:</p>
<div class="highlight"><pre><span></span><code><span class="k">try</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// try 1</span>
<span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// try 2</span>
<span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="n">Threading</span><span class="p">.</span><span class="n">Thread</span><span class="p">.</span><span class="n">CurrentThread</span><span class="p">.</span><span class="n">Abort</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="n">System</span><span class="p">.</span><span class="n">Threading</span><span class="p">.</span><span class="n">ThreadAbortException</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// catch 2</span>
<span class="w">        </span><span class="p">...</span>
<span class="w">        </span><span class="n">LEAVE</span><span class="w"> </span><span class="n">L</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span><span class="w"> </span><span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="n">System</span><span class="p">.</span><span class="n">Exception</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// catch 1</span>
<span class="w">     </span><span class="p">...</span>
<span class="p">}</span>
<span class="n">L</span><span class="p">:</span>
</code></pre></div>
<p>In this case, if the address returned in catch 2 corresponding to label L is outside try 1, then the ThreadAbortException re-raised by the VM will not be caught by catch 1, as is expected. The JIT needs to insert a block such that this is the effective code generation:</p>
<div class="highlight"><pre><span></span><code><span class="k">try</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// try 1</span>
<span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// try 2</span>
<span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="n">Threading</span><span class="p">.</span><span class="n">Thread</span><span class="p">.</span><span class="n">CurrentThread</span><span class="p">.</span><span class="n">Abort</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="n">System</span><span class="p">.</span><span class="n">Threading</span><span class="p">.</span><span class="n">ThreadAbortException</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// catch 2</span>
<span class="w">        </span><span class="p">...</span>
<span class="w">        </span><span class="n">LEAVE</span><span class="w"> </span><span class="n">L</span><span class="err">&#39;</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">L</span><span class="err">&#39;</span><span class="p">:</span><span class="w"> </span><span class="n">LEAVE</span><span class="w"> </span><span class="n">L</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="n">System</span><span class="p">.</span><span class="n">Exception</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// catch 1</span>
<span class="w">     </span><span class="p">...</span>
<span class="p">}</span>
<span class="n">L</span><span class="p">:</span>
</code></pre></div>
<p>Similarly, the automatic re-raise address for a ThreadAbortException can't be within a finally handler, or the VM will abort the re-raise and swallow the exception. This can happen due to call-to-finally thunks marked as "cloned finally", as described above. For example (this is pseudo-assembly-code, not C#):</p>
<div class="highlight"><pre><span></span><code><span class="k">try</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// try 1</span>
<span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// try 2</span>
<span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="n">Threading</span><span class="p">.</span><span class="n">Thread</span><span class="p">.</span><span class="n">CurrentThread</span><span class="p">.</span><span class="n">Abort</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="n">System</span><span class="p">.</span><span class="n">Threading</span><span class="p">.</span><span class="n">ThreadAbortException</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// catch 2</span>
<span class="w">        </span><span class="p">...</span>
<span class="w">        </span><span class="n">LEAVE</span><span class="w"> </span><span class="n">L</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span><span class="w"> </span><span class="k">finally</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// finally 1</span>
<span class="w">     </span><span class="p">...</span>
<span class="p">}</span>
<span class="n">L</span><span class="p">:</span>
</code></pre></div>
<p>This would generate something like:</p>
<div class="highlight"><pre><span></span><code><span class="w">    </span><span class="c1">// beginning of &#39;try 1&#39;</span>
<span class="w">    </span><span class="c1">// beginning of &#39;try 2&#39;</span>
<span class="w">    </span><span class="nf">System.Threading.Thread.CurrentThread.Abort</span><span class="p">()</span><span class="c1">;</span>
<span class="w">    </span><span class="c1">// end of &#39;try 2&#39;</span>
<span class="w">    </span><span class="c1">// beginning of call-to-finally &#39;cloned finally&#39; region</span>
<span class="nl">L1:</span><span class="w"> </span><span class="nf">call</span><span class="w"> </span><span class="no">finally1</span>
<span class="w">    </span><span class="nf">nop</span>
<span class="w">    </span><span class="c1">// end of call-to-finally &#39;cloned finally&#39; region</span>
<span class="w">    </span><span class="c1">// end of &#39;try 1&#39;</span>
<span class="w">    </span><span class="c1">// function epilog</span>
<span class="w">    </span><span class="nf">ret</span>

<span class="nl">Catch2:</span>
<span class="w">    </span><span class="c1">// do something</span>
<span class="w">    </span><span class="nf">lea</span><span class="w"> </span><span class="no">rax</span><span class="p">,</span><span class="w"> </span><span class="err">&amp;</span><span class="no">L1</span><span class="c1">; // load up resume address</span>
<span class="w">    </span><span class="nf">ret</span>

<span class="nl">Finally1:</span>
<span class="w">    </span><span class="c1">// do something</span>
<span class="w">    </span><span class="nf">ret</span>
</code></pre></div>
<p>Note that the JIT must already insert a "step" block so the finally will be called. However, this isn't sufficient to support ThreadAbortException processing, because "L1" is marked as "cloned finally". In this case, the JIT must insert another step block that is within "try 1" but outside the cloned finally block, that will allow for correct re-raise semantics. For example:</p>
<div class="highlight"><pre><span></span><code><span class="w">    </span><span class="c1">// beginning of &#39;try 1&#39;</span>
<span class="w">    </span><span class="c1">// beginning of &#39;try 2&#39;</span>
<span class="w">    </span><span class="nf">System.Threading.Thread.CurrentThread.Abort</span><span class="p">()</span><span class="c1">;</span>
<span class="w">    </span><span class="c1">// end of &#39;try 2&#39;</span>
<span class="nf">L1</span><span class="err">&#39;</span><span class="p">:</span><span class="w">    </span><span class="no">nop</span>
<span class="w">    </span><span class="c1">// beginning of call-to-finally &#39;cloned finally&#39; region</span>
<span class="nl">L1:</span><span class="w"> </span><span class="nf">call</span><span class="w"> </span><span class="no">finally1</span>
<span class="w">    </span><span class="nf">nop</span>
<span class="w">    </span><span class="c1">// end of call-to-finally &#39;cloned finally&#39; region</span>
<span class="w">    </span><span class="c1">// end of &#39;try 1&#39;</span>
<span class="w">    </span><span class="c1">// function epilog</span>
<span class="w">    </span><span class="nf">ret</span>

<span class="nl">Catch2:</span>
<span class="w">    </span><span class="c1">// do something</span>
<span class="w">    </span><span class="nf">lea</span><span class="w"> </span><span class="no">rax</span><span class="p">,</span><span class="w"> </span><span class="err">&amp;</span><span class="no">L1</span><span class="err">&#39;</span><span class="c1">; // load up resume address</span>
<span class="w">    </span><span class="nf">ret</span>

<span class="nl">Finally1:</span>
<span class="w">    </span><span class="c1">// do something</span>
<span class="w">    </span><span class="nf">ret</span>
</code></pre></div>
<p>Note that JIT64 does not implement this properly. The C# compiler used to always insert all necessary "step" blocks. The Roslyn C# compiler at one point did not, but then was changed to once again insert them.</p>
<h2 id="funclet-parameters">Funclet parameters</h2>
<p>Catch, Filter, and Filter-handlers get an Exception object (GC ref) as an argument (<code>REG_EXCEPTION_OBJECT</code>). On AMD64 it is passed in RCX (Windows ABI) or RSI (Unix ABI). On ARM and ARM64 this is the first argument and passed in R0.</p>
<h2 id="funclet-return-values">Funclet Return Values</h2>
<p>The filter funclet returns a simple boolean value in the normal return register (x86: <code>EAX</code>, AMD64: <code>RAX</code>, ARM/ARM64: <code>R0</code>). Non-zero indicates to the VM/EH subsystem that the corresponding filter-handler will handle the exception (i.e. begin the second pass). Zero indicates to the VM/EH subsystem that the exception is <strong>not</strong> handled, and it should continue looking for another filter or catch.</p>
<p>The catch and filter-handler funclets return a code address in the normal return register that indicates where the VM should resume execution after unwinding the stack and cleaning up from the exception. This address should be somewhere in the parent funclet (or main function if the catch or filter-handler is not nested within any other funclet). Because an IL 'leave' opcode can exit out of arbitrary nesting of funclets and try bodies, the JIT is often required to inject step blocks. These are intermediate branch target(s) that then branch to the next outermost target until the real target can be directly reached via the native ABI constraints. These step blocks can also invoke finallys (see <em>Invoking Finallys/Non-local exits</em>).</p>
<p>Finally and fault funclets do not have a return value.</p>
<h2 id="register-values-and-exception-handling">Register values and exception handling</h2>
<p>Exception handling imposes certain restrictions on the usage of registers in functions with exception handling.</p>
<p>CoreCLR and "desktop" CLR behave the same way. Windows and non-Windows implementations of the CLR both follow these rules.</p>
<p>Some definitions:</p>
<p><em>Non-volatile</em> (aka <em>callee-saved</em> or <em>preserved</em>) registers are those defined by the ABI that a function call preserves. Non-volatile registers include the frame pointer and the stack pointer, among others.</p>
<p><em>Volatile</em> (aka <em>caller-saved</em> or <em>trashed</em>) registers are those defined by the ABI that a function call does not preserve, and thus might have a different value when the function returns.</p>
<h3 id="registers-on-entry-to-a-funclet">Registers on entry to a funclet</h3>
<p>When an exception occurs, the VM is invoked to do some processing. If the exception is within a "try" region, it eventually calls a corresponding handler (which also includes calling filters). The exception location within a function might be where a "throw" instruction executes, the point of a processor exception like null pointer dereference or divide by zero, or the point of a call where the callee threw an exception but did not catch it.</p>
<p>The VM sets the frame register to be the same as the parent function. This allows the funclets to access local variables using frame-relative addresses.</p>
<p>For filter funclets, all other register values that existed at the exception point in the corresponding "try" region are trashed on entry to the funclet. That is, the only registers that have known values are those of the funclet parameters and the frame register.</p>
<p>For other funclets, all non-volatile registers are restored to their values at the exception point. The JIT codegen <a href="https://github.com/dotnet/runtime/pull/114630#issuecomment-2810210759">does not take advantage of it currently</a>.</p>
<h3 id="registers-on-return-from-a-funclet">Registers on return from a funclet</h3>
<p>When a funclet finishes execution, and the VM returns execution to the function (or an enclosing funclet, if there is EH clause nesting), the non-volatile registers are restored to the values they held at the exception point. Note that the volatile registers have been trashed.</p>
<p>Any register value changes made in the funclet are lost. If a funclet wants to make a variable change known to the main function (or the funclet that contains the "try" region), that variable change needs to be made to the shared main function stack frame. This not a fundamental limitation. If necessary, the runtime can be updated to preserve non-volatile register changes made in funclets.</p>
<p>Funclets are not required to preserve non-volatile registers.</p>
<h1 id="eh-info-gc-info-and-hot-cold-splitting">EH Info, GC Info, and Hot &amp; Cold Splitting</h1>
<p>All GC info offsets and EH info offsets treat the function and funclets as if it was one big method body. Thus all offsets are relative to the start of the main method. Funclets are assumed to always be at the end of (after) all of the main function code. Thus if the main function has any cold code, all funclets must be cold. Or conversely, if there is any hot funclet code, all of the main method must be hot.</p>
<h2 id="eh-clause-ordering">EH clause ordering</h2>
<p>EH clauses must be sorted inner-to-outer, first-to-last based on IL offset of the try start/try end pair. The only exceptions are cloned finallys, which always appear at the end.</p>
<h2 id="how-eh-affects-gc-inforeporting">How EH affects GC info/reporting</h2>
<p>Because a main function body will <strong>always</strong> be on the stack when one of its funclets is on the stack, the GC info must be careful not to double-report. JIT64 accomplished this by having all named locals appear in the parent method frame, anything shared between the function and funclets was homed to the stack, and only the parent function reported stack locals (funclets might report local registers). JIT32 and RyuJIT (for AMD64, ARM, and ARM64) take the opposite direction. The leaf-most funclet is responsible for reporting everything that might be live out of a funclet (in the case of a filter, this might resume back in the original method body). This is accomplished with the GC header flag WantsReportOnlyLeaf (JIT32 and RyuJIT set it, JIT64 doesn't) and the VM tracking if it has already seen a funclet for a given frame. Once JIT64 is fully retired, we should be able to remove this flag from GC info.</p>
<p>There is one "corner case" in the VM implementation of WantsReportOnlyLeaf model that has implications for the code the JIT is allowed to generate. Consider this function with nested exception handling:</p>
<div class="highlight"><pre><span></span><code><span class="k">public</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="nf">runtest</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">try</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">throw</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nf">UserException3</span><span class="p">(</span><span class="n">ThreadId</span><span class="p">);</span><span class="w"> </span><span class="c1">// 1</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="n">UserException3</span><span class="w"> </span><span class="n">e</span><span class="p">){</span>
<span class="w">            </span><span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&quot;Exception3 was caught&quot;</span><span class="p">);</span>
<span class="w">            </span><span class="k">throw</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nf">UserException4</span><span class="p">(</span><span class="n">ThreadId</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="n">UserException4</span><span class="w"> </span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// 2</span>
<span class="w">        </span><span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&quot;Exception4 was caught&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>When the inner "throw new UserException4" is executed, the exception handling first pass finds that the outer catch handler will handle the exception. The exception handling second pass unwinds stack frames back to the "runtest" frame, and then executes the catch handler. There is a period of time during which the original catch handler ("catch (UserException3 e)") is no longer on the stack, but before the new catch handler is executed. During this time, a GC might occur. In this case, the VM needs to make sure to report GC roots properly for the "runtest" function. The inner catch has been unwound, so we can't report that. We don't want to report at "// 1", which is still on the stack, because that effectively is "going backwards" in execution, and doesn't properly represent what object references are live. We need to report live object references at the next location where execution will occur. This is the "// 2" location. However, we can't report the first location of the catch funclet, as that will be non-interruptible. The VM instead looks forward for the first interruptible point in that handler, and reports live references that the JIT reports for that location. This will be the first location after the handler prolog. There are several implications of this implementation for the JIT. It requires that:</p>
<ol>
<li>Methods which have EH clauses are fully interruptible.</li>
<li>All catch funclets have an interruptible point immediately after the prolog.</li>
<li>The first interruptible point in the catch funclet reports the following live objects on the stack<ul>
<li>Only objects that are shared with parent method i.e. no additional stack object which is live only in catch funclet and not live in parent method.</li>
<li>All shared objects which are referenced in catch funclet and any subsequent control flow are reported live.</li>
</ul>
</li>
</ol>
<h2 id="filter-gc-semantics">Filter GC semantics</h2>
<p>Filters are invoked in the 1st pass of EH processing and as such execution might resume back at the faulting address, or in the filter-handler, or someplace else. Because the VM must allow GC's to occur during and after a filter invocation, but before the EH subsystem knows where it will resume, we need to keep everything alive at both the faulting address <strong>and</strong> within the filter. This is accomplished by 3 means: (1) the VM's stackwalker and GCInfoDecoder report as live both the filter frame and its corresponding parent frame, (2) the JIT encodes all stack slots that are live within the filter as being pinned, and (3) the JIT reports as live (and possible zero-initializes) anything live-out of the filter. Because of (1) it is likely that a stack variable that is live within the filter and the try body will be double reported. During the mark phase of the GC double reporting is not a problem. The problem only arises if the object is relocated: if the same location is reported twice, the GC will try to relocate the address stored at that location twice. Thus we prevent the object from being relocated by pinning it, which leads us to why we must do (2). (3) is done so that after the filter returns, we can still safely incur a GC before executing the filter-handler or any outer handler within the same frame. For the same reason, control must exit a filter region via its final block (in other words, a filter region must terminate with the instruction that leaves the filter region, and the program may not exit the filter region via other paths).</p>
<h2 id="clauses-covering-the-same-try-region">Clauses covering the same try region</h2>
<p>Several consecutive clauses may cover the same <code>try</code> block. A clause covering the same region as the previous one is marked by the <code>COR_ILEXCEPTION_CLAUSE_SAMETRY</code> flag. When exception ex1 is thrown while running handler for another exception ex2 and the exception ex2 escapes the ex1's handler frame, this enables the runtime to skip clauses that cover the same <code>try</code> block as the clause that handled the ex1.
This flag is used by the NativeAOT and also a new exception handling mechanism in CoreCLR. The NativeAOT doesn't store that flag in the encoded clause data, but rather injects a dummy clause between the clauses with same <code>try</code> block. CoreCLR keeps that flag as part of the runtime representation of the clause data. The current CoreCLR exception handling doesn't use it, but <a href="https://github.com/dotnet/runtime/issues/77568">a new exception handling mechanism</a> that's being developed is taking advantage of it.</p>
<h2 id="gc-interruptibility-and-eh">GC Interruptibility and EH</h2>
<p>The VM assumes that anytime a thread is stopped, it must be at a GC safe point, or the current frame is non-resumable (i.e. a throw that will never be caught in the same frame). Thus effectively all methods with EH must be fully interruptible (or at a minimum all try bodies). Currently the GC info appears to support mixing of partially interruptible and fully-interruptible regions within the same method, but no JIT uses this, so use at your own risk.</p>
<p>The debugger always wants to stop at GC safe points, and thus debuggable code should be fully interruptible to maximize the places where the debugger can safely stop. If the JIT creates non-interruptible regions within fully interruptible code, the code should ensure that each sequence point begins on an interruptible instruction.</p>
<p>AMD64/JIT64 only: The JIT will add an interruptible NOP if needed.</p>
<h2 id="security-object">Security Object</h2>
<p>The security object is a GC pointer and must be reported as such, and kept alive the duration of the method.</p>
<h2 id="gs-cookie">GS Cookie</h2>
<p>The GS Cookie is not a GC object, but still needs to be reported. It can only have one lifetime due to how it is encoded/reported in the GC info. Since the GS Cookie ceases being valid once we pop the stack, the epilog cannot be part of the live range. Since we only get one live range that means there cannot be any code (except funclets) after the epilog in methods with a GS cookie.</p>
<h2 id="nops-and-other-padding">NOPs and other Padding</h2>
<h3 id="amd64-padding-info">AMD64 padding info</h3>
<p>The unwind callbacks don't know if the current frame is a leaf or a return address. Consequently, the JIT must ensure that the return address of a call is in the same region as the call. Specifically, the JIT must add a NOP (or some other instruction) after any call that otherwise would directly precede the start of a try body, the end of a try body, or the end of a method.</p>
<p>The OS has an optimization in the unwinder such that if an unwind results in a PC being within (or at the start of) an epilog, it assumes that frame is unimportant and unwinds again. Since the CLR considers every frame important, it does not want this double-unwind behavior and requires the JIT to place a NOP (or other instruction) between any call and any epilog.</p>
<h3 id="arm-and-arm64-padding-info">ARM and ARM64 padding info</h3>
<p>The OS unwinder uses the <code>RUNTIME_FUNCTION</code> extents to determine which function or funclet to unwind out of. The net result is that a call (bl opcode) to <code>IL_Throw</code> cannot be the last thing. So similar to AMD64 the JIT must inject an opcode (a breakpoint in this case) when the <code>bl IL_Throw</code> would otherwise be the last opcode of a function or funclet, the last opcode before the end of the hot section, or (this might be an x86-ism leaking into ARM) the last before a "special throw block".</p>
<h1 id="profiler-hooks">Profiler Hooks</h1>
<p>If the JIT gets passed <code>CORJIT_FLG_PROF_ENTERLEAVE</code>, then the JIT might need to insert native entry/exit/tail call probes. To determine for sure, the JIT must call GetProfilingHandle. This API returns as out parameters, the true dynamic boolean indicating if the JIT should actually insert the probes and a parameter to pass to the callbacks (typed as void*), with an optional indirection (used for NGEN). This parameter is always the first argument to all of the call-outs (thus placed in the usual first argument register <code>RCX</code> (AMD64) or <code>R0</code> (ARM, ARM64)).</p>
<p>Outside of the prolog (in a GC interruptible location), the JIT injects a call to <code>CORINFO_HELP_PROF_FCN_ENTER</code>. For AMD64,  on Windows all argument registers will be homed into their caller-allocated stack locations (similar to varargs), on Unix all argument registers will be stored in the inner structure. For ARM and ARM64, all arguments are prespilled (again similar to varargs).</p>
<p>After computing the return value and storing it in the correct register, but before any epilog code (including before a possible GS cookie check), the JIT injects a call to <code>CORINFO_HELP_PROF_FCN_LEAVE</code>. For AMD64 this call must preserve the return register: <code>RAX</code> or <code>XMM0</code> on Windows and <code>RAX</code> and <code>RDX</code> or <code>XMM0</code> and <code>XMM1</code> on Unix. For ARM, the return value will be moved from <code>R0</code> to <code>R2</code> (if it was in <code>R0</code>), <code>R1</code>, <code>R2</code>, and <code>S0/D0</code> must be preserved by the callee (longs will be <code>R2</code>, <code>R1</code> - note the unusual ordering of the registers, floats in <code>S0</code>, doubles in <code>D0</code>, smaller integrals in <code>R2</code>).</p>
<p>TODO: describe ARM64 profile leave conventions.</p>
<p>Before the argument setup (but after any argument side-effects) for any tail calls or jump calls, the JIT injects a call to <code>CORINFO_HELP_PROF_FCN_TAILCALL</code>. Note that it is NOT called for self-recursive tail calls turned into loops.</p>
<p>For ARM tail calls, the JIT actually loads the outgoing arguments first, and then just before the profiler call-out, spills the argument in <code>R0</code> to another non-volatile register, makes the call (passing the callback parameter in <code>R0</code>), and then restores <code>R0</code>.</p>
<p>For AMD64, all probes receive a second parameter (passed in <code>RDX</code> according to the default argument rules) which is the address of the start of the arguments' home location (equivalent to the value of the caller's stack pointer).</p>
<p>TODO: describe ARM64 tail call convention.</p>
<p>On Linux/x86 the profiling hooks are declared with the <code>__cdecl</code> attribute.  In cdecl (which stands for C declaration), subroutine arguments are passed on the stack. Integer values and memory addresses are returned in the EAX register, floating point values in the ST0 x87 register. Registers EAX, ECX, and EDX are caller-saved, and the rest are callee-saved. The x87 floating point registers ST0 to ST7 must be empty (popped or freed) when calling a new function, and ST1 to ST7 must be empty on exiting a function. ST0 must also be empty when not used for returning a value. Returned values of managed-code are formed before the leave/tailcall profiling hooks, so they should be saved in these hooks and restored on returning from them. The instruction <code>ret</code> for assembler implementations of profiling hooks should be without a parameter.</p>
<p>JIT32 only generates one epilog (and causes all returns to branch to it) when there are profiler hooks.</p>
<h1 id="synchronized-methods">Synchronized Methods</h1>
<p>JIT32/RyuJIT only generates one epilog (and causes all returns to branch to it) when a method is synchronized. See <code>Compiler::fgAddSyncMethodEnterExit()</code>. The user code is wrapped in a try/finally. Outside/before the try body, the code initializes a boolean to false. <code>CORINFO_HELP_MON_ENTER</code> or <code>CORINFO_HELP_MON_ENTER_STATIC</code> are called, passing the lock object (the <code>this</code> pointer for instance methods or the Type object for static methods) and the address of the boolean. If the lock is acquired, the boolean is set to true (as an 'atomic' operation in the sense that a Thread.Abort/EH/GC/etc. cannot interrupt the Thread when the boolean does not match the acquired state of the lock). JIT32/RyuJIT follows the exact same logic and arguments for placing the call to <code>CORINFO_HELP_MON_EXIT</code> /  <code>CORINFO_HELP_MON_EXIT_STATIC</code> in the finally.</p>
<h1 id="rejit">Rejit</h1>
<p>For AMD64 to support profiler attach scenarios, the JIT can be required to ensure every generated method is hot patchable (see <code>CORJIT_FLG_PROF_REJIT_NOPS</code>). The way we do this is to ensure that the first 5 bytes of code are non-interruptible and there is no branch target within those bytes (includes calls/returns). Thus the VM can stop all threads (like for a GC) and safely replace those 5 bytes with a branch to a new version of the method (presumably instrumented by a profiler). The JIT adds NOPs or increases the size of the prolog reported in the GC info to accomplish these 2 requirements.</p>
<p>In a function with exception handling, only the main function is affected; the funclet prologs are not made hot patchable.</p>
<h1 id="edit-and-continue">Edit and Continue</h1>
<p>Edit and Continue (EnC) is a special flavor of un-optimized code. The debugger has to be able to reliably remap a method state (instruction pointer and local variables) from original method code to edited method code. This puts constraints on the method stack layout performed by the JIT. The key constraint is that the addresses of the existing locals must stay the same after the edit. This constraint is required because the address of the local could have been stored in the method state.</p>
<p>In the current design, the JIT does not have access to the previous versions of the method and so it has to assume the worst case. EnC is designed for simplicity, not for performance of the generated code.</p>
<p>EnC is currently enabled on x86, x64 and ARM64 only, but the same principles would apply if it is ever enabled on other platforms.</p>
<p>The following sections describe the various Edit and Continue code conventions that must be followed.</p>
<h2 id="enc-flag-in-gcinfo">EnC flag in GCInfo</h2>
<p>The JIT records the fact that it has followed conventions for EnC code in GC Info. On x64/ARM64, this flag is implied by recording the size of the stack frame region preserved between EnC edits (<code>GcInfoEncoder::SetSizeOfEditAndContinuePreservedArea</code>). For x64 the size of this region is increased to include <code>RSI</code> and <code>RDI</code>, so that <code>rep stos</code> can be used for block initialization and block moves. ARM64 saves only the FP and LR registers when EnC is enabled and does not use other callee saved registers.</p>
<p>To successfully perform EnC transitions the runtime needs to know the size of the stack frames it is transitioning between. For x64 code the size can be extracted from unwind codes. This is not possible for arm64 code as the frames are set up in such a way that the unwind codes do not allow to retrieve this value. Therefore, on ARM64 the GC info contains also the size of the fixed stack frame to be used for EnC purposes.</p>
<h2 id="allocating-local-variables-backward">Allocating local variables backward</h2>
<p>This is required to preserve addresses of the existing locals when an EnC edit appends new ones. In other words, the first local must be allocated at the highest stack address. Special care has to be taken to deal with alignment. The total size of the method frame can either grow (more locals added) or shrink (fewer temps needed) after the edit. The VM zeros out newly added locals.</p>
<h2 id="fixed-set-of-callee-saved-registers">Fixed set of callee-saved registers</h2>
<p>This eliminates need to deal with the different sets in the VM, and makes preservation of local addresses easier. There are plenty of volatile registers and so lack of non-volatile registers does not heavily impact quality of non-optimized code.
x64 currently saves RBP, RSI and RDI while ARM64 saves just FP and LR.</p>
<h2 id="enc-is-supported-for-methods-with-eh">EnC is supported for methods with EH</h2>
<p>However, EnC remap is not supported inside funclets. The stack layout of funclets does not matter for EnC.</p>
<h2 id="localloc">Localloc</h2>
<p>Localloc is allowed in EnC code, but remap is disallowed after the method has executed a localloc instruction. VM uses the invariants above (<code>RSP == RBP</code> on x64, <code>FP + 16 == SP + stack size</code> on ARM64) to detect whether localloc was executed by the method.</p>
<h2 id="security-object_1">Security object</h2>
<p>This does not require any special handling by the JIT on x64/arm64. (Different from x86). The security object is copied over by the VM during remap if necessary. Location of security object is found via GC info.</p>
<h2 id="synchronized-methods_1">Synchronized methods</h2>
<p>The extra state created by the JIT for synchronized methods (lock taken flag) must be preserved during remap. The JIT stores this state in the preserved region, and increases the size of the preserved region reported in GC info accordingly.</p>
<h2 id="generics_1">Generics</h2>
<p>EnC is supported for adding and editing generic methods and methods on generic types and generic methods on non-generic types.</p>
<h1 id="portable-entrypoints">Portable entrypoints</h1>
<p>On platforms that allow dynamic code generation, the runtime abstracts away execution strategies for dynamically loaded methods by allocating <a href="../method-descriptor/#precode"><code>Precode</code></a>s. The <code>Precode</code> is a small code fragment that is used as a temporary method entrypoint until the actual method code is acquired. <code>Precode</code>s are also used as part of the execution for methods that do not have regular JITed or AOT-compiled code, for example stubs or interpreted methods. <code>Precode</code>s allow native code to use the same native code calling convention irrespective of the execution strategy used by the target method.</p>
<p>On platforms that do not allow dynamic code generation (Wasm), the runtime abstracts away execution strategies by allocating portable entrypoints for dynamically loaded methods. The <code>PortableEntryPoint</code> is a data structure that allows efficient transition to the desired execution strategy for the target method. When the runtime is configured to use portable entrypoints, the managed calling convention is modified as follows:</p>
<ul>
<li>
<p>The native code to call is obtained by dereferencing the entrypoint</p>
</li>
<li>
<p>The entrypoint address is passed in as an extra last hidden argument. The extra hidden argument must be present in signatures of all methods. It is unused by the code of JITed or AOT-compiled methods.</p>
</li>
</ul>
<p>Pseudo code for a call with portable entrypoints:</p>
<blockquote>
<p><code>(*(void**)pfn)(arg0, arg1, ..., argN, pfn)</code></p>
</blockquote>
<p>Portable entrypoints are used for Wasm with interpreter only currently. Note that portable entrypoints are unnecessary for Wasm with native AOT since native AOT does not support dynamic loading.</p>
<h1 id="system-v-x86_64-support">System V x86_64 support</h1>
<p>This section relates mostly to calling conventions on System V systems (such as Ubuntu Linux and Mac OS X).
The general rules outlined in the System V x86_64 ABI documentation are followed with a few exceptions, described below:</p>
<ol>
<li>The hidden argument for by-value passed structs is always after the <code>this</code> parameter (if there is one). This is a difference with the System V ABI and affects only the internal JIT calling conventions. For PInvoke calls the hidden argument is always the first parameter since there is no <code>this</code> parameter in this case (except for the <code>CallConvMemberFunction</code> case).</li>
<li>Managed structs that have no fields are always passed by-value on the stack.</li>
<li>The JIT proactively generates frame register frames (with <code>RBP</code> as a frame register) in order to aid the native OS tooling for stack unwinding and the like.</li>
<li>All the other internal VM contracts for PInvoke, EH, and generic support remains in place. Please see the relevant sections above for more details. Note, however, that the registers used are different on System V due to the different calling convention. For example, the integer argument registers are, in order, RDI, RSI, RDX, RCX, R8, and R9. Thus, where the first argument (typically, the <code>this</code> pointer) on Windows AMD64 goes in RCX, on System V it goes in RDI, and so forth.</li>
<li>Structs with explicit layout are always passed by value on the stack.</li>
<li>The following table describes register usage according to the System V x86_64 ABI</li>
</ol>
<div class="highlight"><pre><span></span><code>| Register      | Usage                                   | Preserved across  |
|               |                                         | function calls    |
|---------------|-----------------------------------------|-------------------|
| %rax          | temporary register; with variable argu- | No                |
|               | ments passes information about the      |                   |
|               | number of SSE registers used;           |                   |
|               | 1st return argument                     |                   |
| %rbx          | callee-saved register; optionally used  | Yes               |
|               | as base pointer                         |                   |
| %rcx          | used to pass 4st integer argument to    | No                |
|               | to functions                            |                   |
| %rdx          | used to pass 3rd argument to functions  | No                |
|               | 2nd return register                     |                   |
| %rsp          | stack pointer                           | Yes               |
| %rbp          | callee-saved register; optionally used  | Yes               |
|               | as frame pointer                        |                   |
| %rsi          | used to pass 2nd argument to functions  | No                |
| %rdi          | used to pass 1st argument to functions  | No                |
| %r8           | used to pass 5th argument to functions  | No                |
| %r9           | used to pass 6th argument to functions  | No                |
| %r10          | temporary register, used for passing a  | No                |
|               | function&#39;s static chain pointer         |                   |
| %r11          | temporary register                      | No                |
| %r12-%r15     | callee-saved registers                  | Yes               |
| %xmm0-%xmm1   | used to pass and return floating point  | No                |
|               | arguments                               |                   |
| %xmm2-%xmm7   | used to pass floating point arguments   | No                |
| %xmm8-%xmm31  | temporary registers                     | No                |
</code></pre></div>
<h1 id="calling-convention-specifics-for-x86">Calling convention specifics for x86</h1>
<p>Unlike the other architectures that RyuJIT supports, the managed x86 calling convention is different than the default native calling convention. This is true for both Windows and Unix x86.</p>
<p>The standard managed calling convention is a variation on the Windows x86 fastcall convention. It differs primarily in the order in which arguments are pushed on the stack.</p>
<p>The only values that can be passed in registers are managed and unmanaged pointers, object references, and the built-in integer types int8, unsigned int8, int16, unsigned int16, int32, unsigned it32, native int, native unsigned int, and enums and value types with only one 4-byte integer primitive-type field. Enums are passed as their underlying type. All floating-point values and 8-byte integer values are passed on the stack. When the return type is a value type that cannot be passed in a register, the caller shall create a buffer to hold the result and pass the address of this buffer as a hidden parameter.</p>
<p>Arguments are passed in left-to-right order, starting with the <code>this</code> pointer (for instance and virtual methods), followed by the return buffer pointer if needed, followed by the user-specified argument values. The first of these that can be placed in a register is put into ECX, the next in EDX, and all subsequent ones are passed on the stack. This is in contrast with the x86 native calling conventions, which push arguments onto the stack in right-to-left order.</p>
<p>The return value is handled as follows:</p>
<ol>
<li>Floating-point values are returned on the top of the hardware FP stack.</li>
<li>Integers up to 32 bits long are returned in EAX.</li>
<li>64-bit integers are passed with EAX holding the least significant 32 bits and EDX holding the most significant 32 bits.</li>
<li>All other cases require the use of a return buffer, through which the value is returned. See <a href="#return-buffers">Return buffers</a>.</li>
</ol>
<h1 id="control-flow-guard-cfg-support-on-windows">Control Flow Guard (CFG) support on Windows</h1>
<p>Control Flow Guard (CFG) is a security mitigation available in Windows.
When CFG is enabled, the operating system maintains data structures that can be used to verify whether an address is to be considered a valid indirect call target.
This mechanism is exposed through two different helper functions, each with different characteristics.</p>
<p>The first mechanism is a validator that takes the target address as an argument and fails fast if the address is not an expected indirect call target; otherwise, it does nothing and returns.
The second mechanism is a dispatcher that takes the target address in a non-standard register; on successful validation of the address, it jumps directly to the target function.
Windows makes the dispatcher available only on ARM64 and x64, while the validator is available on all platforms.
However, the JIT supports CFG only on ARM64 and x64, with CFG by default being disabled for these platforms.
The expected use of the CFG feature is for NativeAOT scenarios that are running in constrained environments where CFG is required.</p>
<p>The helpers are exposed to the JIT as standard JIT helpers <code>CORINFO_HELP_VALIDATE_INDIRECT_CALL</code> and <code>CORINFO_HELP_DISPATCH_INDIRECT_CALL</code>.</p>
<p>To use the validator the JIT expands indirect calls into a call to the validator followed by a call to the validated address.
For the dispatcher the JIT will transform calls to pass the target along but otherwise set up the call as normal.</p>
<p>Note that "indirect call" here refers to any call that is not to an immediate (in the instruction stream) address.
For example, even direct calls may emit indirect call instructions in JIT codegen due to e.g. tiering or if they have not been compiled yet; these are expanded with the CFG mechanism as well.</p>
<p>The next sections describe the calling convention that the JIT expects from these helpers.</p>
<h2 id="cfg-details-for-arm64">CFG details for ARM64</h2>
<p>On ARM64, <code>CORINFO_HELP_VALIDATE_INDIRECT_CALL</code> takes the call address in <code>x15</code>.
In addition to the usual registers it preserves all float registers, <code>x0</code>-<code>x8</code> and <code>x15</code>.</p>
<p><code>CORINFO_HELP_DISPATCH_INDIRECT_CALL</code> takes the call address in <code>x9</code>.
The JIT does not use the dispatch helper by default due to worse branch predictor performance.
Therefore it will expand all indirect calls via the validation helper and a manual call.</p>
<h2 id="cfg-details-for-x64">CFG details for x64</h2>
<p>On x64, <code>CORINFO_HELP_VALIDATE_INDIRECT_CALL</code> takes the call address in <code>rcx</code>.
In addition to the usual registers it also preserves all float registers, <code>rcx</code>, and <code>r10</code>; furthermore, shadow stack space is not required to be allocated.</p>
<p><code>CORINFO_HELP_DISPATCH_INDIRECT_CALL</code> takes the call address in <code>rax</code> and it reserves the right to use and trash <code>r10</code> and <code>r11</code>.
The JIT uses the dispatch helper on x64 whenever possible as it is expected that the code size benefits outweighs the less accurate branch prediction.
However, note that the use of <code>r11</code> in the dispatcher makes it incompatible with VSD calls where the JIT must fall back to the validator and a manual call.</p>
<h1 id="notes-on-memsetmemcpy">Notes on Memset/Memcpy</h1>
<p>Generally, <code>memset</code> and <code>memcpy</code> do not provide any guarantees of atomicity. This implies that they should only be used when the memory being modified by <code>memset</code>/<code>memcpy</code> is not observable by any other thread (including GC), or when there are no atomicity requirements according to our <a href="https://github.com/dotnet/runtime/blob/main/docs/design/specs/Memory-model.md">Memory Model</a>. It's especially important when we modify heap containing managed pointers - those must be updated atomically, e.g. using pointer-sized <code>mov</code> instruction (managed pointers are always aligned) - see <a href="https://github.com/dotnet/runtime/blob/main/docs/design/specs/Memory-model.md#Atomic-memory-accesses">Atomic Memory Access</a>. It's worth noting that by "update" it's implied "set to zero", otherwise, we need a write barrier.</p>
<p>Examples:</p>
<div class="highlight"><pre><span></span><code><span class="k">struct</span><span class="w"> </span><span class="nc">MyStruct</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">long</span><span class="w"> </span><span class="n">a</span><span class="p">;</span>
<span class="w">    </span><span class="kt">string</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">void</span><span class="w"> </span><span class="nf">Test1</span><span class="p">(</span><span class="k">ref</span><span class="w"> </span><span class="n">MyStruct</span><span class="w"> </span><span class="n">m</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// We&#39;re not allowed to use memset here</span>
<span class="w">    </span><span class="n">m</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">default</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">MyStruct</span><span class="w"> </span><span class="nf">Test2</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// We can use memset here</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">default</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>







  
  



  


  



                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
    
      
        
      
      <nav class="md-footer__inner md-grid" aria-label="Footer" >
        
          
          <a href="../readytorun-overview/" class="md-footer__link md-footer__link--prev" aria-label="Previous: ReadyToRun Overview">
            <div class="md-footer__button md-icon">
              
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
            </div>
            <div class="md-footer__title">
              <span class="md-footer__direction">
                Previous
              </span>
              <div class="md-ellipsis">
                ReadyToRun Overview
              </div>
            </div>
          </a>
        
        
          
          <a href="../xplat-minidump-generation/" class="md-footer__link md-footer__link--next" aria-label="Next: Cross-platform Minidumps">
            <div class="md-footer__title">
              <span class="md-footer__direction">
                Next
              </span>
              <div class="md-ellipsis">
                Cross-platform Minidumps
              </div>
            </div>
            <div class="md-footer__button md-icon">
              
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M4 11v2h12l-5.5 5.5 1.42 1.42L19.84 12l-7.92-7.92L10.5 5.5 16 11z"/></svg>
            </div>
          </a>
        
      </nav>
    
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
        
in <a href="https://github.com/jurakovic/runtime" target="_blank">jurakovic/runtime</a>
<div class="md-social">
  
    
    
    
    
      
      
    
    <a href="https://github.com/jurakovic/runtime" target="_blank" rel="noopener" title="github.com" class="md-social__link">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 7.1.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2025 Fonticons, Inc.--><path d="M173.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6m-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3m44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9M252.8 8C114.1 8 8 113.3 8 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C436.2 457.8 504 362.9 504 252 504 113.3 391.5 8 252.8 8M105.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1m-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7m32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1m-11.4-14.7c-1.6 1-1.6 3.6 0 5.9s4.3 3.3 5.6 2.3c1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2"/></svg>
    </a>
  
    
    
    
    
      
      
    
    <a href="https://github.com/dotnet/runtime" target="_blank" rel="noopener" title="github.com" class="md-social__link">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 7.1.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2025 Fonticons, Inc.--><path d="M173.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6m-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3m44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9M252.8 8C114.1 8 8 113.3 8 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C436.2 457.8 504 362.9 504 252 504 113.3 391.5 8 252.8 8M105.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1m-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7m32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1m-11.4-14.7c-1.6 1-1.6 3.6 0 5.9s4.3 3.3 5.6 2.3c1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2"/></svg>
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    
      
      <script id="__config" type="application/json">{"base": "..", "features": ["content.action.view", "navigation.footer", "navigation.instant", "navigation.indexes"], "search": "../assets/javascripts/workers/search.973d3a69.min.js", "tags": null, "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}, "version": null}</script>
    
    
      <script src="../assets/javascripts/bundle.f55a23d4.min.js"></script>
      
    
  </body>
</html>